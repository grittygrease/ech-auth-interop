# ECH Auth Interop

Reference implementations of [draft-sullivan-tls-signed-ech-updates](https://datatracker.ietf.org/doc/draft-sullivan-tls-signed-ech-updates/) in Rust and Go.

This draft defines authenticated ECH configuration distribution, allowing TLS clients to verify that ECH retry configs received during handshake rejection come from the legitimate server operator.

## Authentication Methods

### RPK (Raw Public Key)

Uses SPKI hash pinning similar to HPKP/DANE. The client pins SHA-256 hashes of trusted public keys and verifies signatures directly.

Supported algorithms:
- Ed25519 (recommended)
- ECDSA P-256

### PKIX (Certificate Chain)

Uses X.509 certificate chains with WebPKI validation. Requires certificates with the `id-pe-echConfigSigning` extension.

## Structure

```
.
├── rust/           # Rust implementation (ech-auth crate)
│   ├── src/
│   │   ├── lib.rs
│   │   ├── codec.rs      # Wire format encoding/decoding
│   │   ├── types.rs      # Auth struct and methods
│   │   ├── sign.rs       # Signing operations
│   │   ├── verify.rs     # Verification with webpki
│   │   ├── ech_config.rs # ECHConfig parsing
│   │   └── bin/          # CLI tools
│   └── Cargo.toml
└── go/             # Go implementation (echauth package)
    ├── echauth.go        # Core types and RPK
    ├── pkix.go           # PKIX signing
    ├── config.go         # ECHConfig parsing and verification
    ├── *_test.go         # Tests including E2E TLS
    └── go.mod
```

## Usage

### Rust

```bash
cd rust
cargo build --release

# Generate a signing key
cargo run --bin ech-generate -- --algorithm ed25519 --output key.json

# Sign an ECHConfig
cargo run --bin ech-sign -- --key key.json --config echconfig.bin --output signed.bin

# Verify a signed ECHConfig
cargo run --bin ech-verify -- --config signed.bin --trust-anchor <spki-hash>
```

### Go

```go
import "github.com/grittygrease/ech-auth-interop/go"

// Create RPK auth with Ed25519
priv, _ := ed25519.GenerateKey(rand.Reader)
auth := echauth.NewRPKAuth(echauth.AlgEd25519, priv)

// Sign ECH config
now := uint64(time.Now().Unix())
signed, _ := auth.Sign(echConfigBytes, now, now+86400)

// Verify with pinned SPKI hash
anchor := &echauth.TrustAnchor{TrustedKeys: []echauth.SPKIHash{spkiHash}}
configs, err := echauth.VerifyConfigList(signedConfigList, anchor, func() uint64 {
    return uint64(time.Now().Unix())
})
```

## Testing

### Rust

```bash
cd rust
cargo test
```

42 tests covering:
- Wire format encoding/decoding
- Ed25519 and ECDSA P-256 signing/verification
- SPKI hash computation
- Timestamp validation
- Error cases

### Go

```bash
cd go
go test -v
```

87 tests covering:
- All Rust test cases
- ECHConfig/ECHConfigList parsing
- Full client flow simulation
- End-to-end TLS 1.3 ECH handshakes
- ECH rejection and retry scenarios

### Interop

The Go tests include interop verification against test vectors generated by the Rust implementation:

```bash
# Generate test vector from Rust
cd rust
cargo run --bin gen-test-vector > ../test-vector.json

# Verify in Go
cd ../go
go test -run TestInterop -v
```

## Wire Format

The `ech_auth` extension (type TBD) in ECHConfig:

```
struct {
    AuthMethod method;           // 1 byte: 0=none, 1=rpk, 2=pkix
    uint64 not_before;          // 8 bytes
    uint64 not_after;           // 8 bytes
    SignatureAlgorithm alg;     // 2 bytes
    opaque spki<0..2^16-1>;     // Public key (RPK) or cert chain (PKIX)
    opaque signature<0..2^16-1>;
} ECHAuthExtension;
```

## Security Considerations

- **Time validation**: Both implementations enforce not_before/not_after bounds
- **Algorithm agility**: Supports multiple signature algorithms
- **Fail-closed**: Empty trust anchors reject all configs (no silent fallback)
- **Legacy mode**: Nil/null trust anchor allows unverified configs for gradual deployment

## License

MIT OR Apache-2.0
